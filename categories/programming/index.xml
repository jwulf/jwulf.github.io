<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>programming on Josh Wulf</title>
    <link>https://joshwulf.com/categories/programming/</link>
    <description>Recent content in programming on Josh Wulf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 29 Feb 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://joshwulf.com/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Refactoring the Zeebe Node gRPC State Machine for Camunda Cloud: Part One</title>
      <link>https://joshwulf.com/blog/2020/02/camunda-cloud-connection/</link>
      <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/02/camunda-cloud-connection/</guid>
      <description>Preparing for the launch of Camunda Cloud, I turned on continuous integration testing for the Zeebe Node client against a running instance of a Camunda Cloud Zeebe cluster.
I was immediately forced to deal with something I&#39;d been conveniently ignoring - Camunda Cloud gRPC connections always report failure initially, before eventually succeeding.
This is because the connection to Camunda Cloud is via a TLS-enabled Nginx reverse proxy with OAuth authentication. This causes the current gRPC client state machine to emit intermediate connection failure events before emitting an eventual &amp;ldquo;READY&amp;rdquo; state.</description>
    </item>
    
    <item>
      <title>A Functional Refactor of Zeebe Node with fp-ts</title>
      <link>https://joshwulf.com/blog/2020/02/functional-refactor/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/02/functional-refactor/</guid>
      <description>There is no such thing as good coding, only good refactoring.
 I recently did a bunch of work on the Zeebe Node.js client for the upcoming 0.23 release. Zeebe Node is a client library for the Zeebe Microservices Workflow Orchestration Engine, and I maintain it.
While doing other work, I took the opportunity to refactor one method, deployWorkflows, to add a feature that I wanted it to have. I used fp-ts, a TypeScript Functional Programming library to do it.</description>
    </item>
    
    <item>
      <title>Providing a Semantic API</title>
      <link>https://joshwulf.com/blog/2020/02/providing-a-semantic-api/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/02/providing-a-semantic-api/</guid>
      <description>This is part of a series of posts where I refactor code from StackOverflow questions, with a discussion of the changes. One of the great things about JavaScript is how scalable it is. You can start with a simple script, and there is nothing wrong with that. Usually these posts are about refactorings other than what the questioner asked about, and would be out of scope for the SO answer. There is nothing wrong with code that runs, and &amp;ldquo;There is no such thing as good coding, only good refactoring&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Shun the Mutant - the case for const</title>
      <link>https://joshwulf.com/blog/2020/02/shun-the-mutant/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/02/shun-the-mutant/</guid>
      <description>There are three ways you can declare and assign in JS in 2020:
let a = &amp;quot;Hello&amp;quot; var b = &amp;quot;World&amp;quot; const c = &amp;quot;!&amp;quot; These are &amp;ldquo;declarations with assignment&amp;rdquo;, as opposed to &amp;ldquo;declaration without assignment&amp;rdquo; - which can only be done with let and var:
let a; var b; const c; // has no meaning To understand the difference between let and var, you can refer to this excellent answer on StackOverflow.</description>
    </item>
    
    <item>
      <title>Avoiding global mutable state in browser JS</title>
      <link>https://joshwulf.com/blog/2020/02/avoid-global-state/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/02/avoid-global-state/</guid>
      <description>This is part of a series of posts where I refactor code from StackOverflow questions, with a discussion of the changes. One of the great things about JavaScript is how scalable it is. You can start with a simple script, and there is nothing wrong with that. Usually these posts are about refactorings other than what the questioner asked about, and would be out of scope for the SO answer.</description>
    </item>
    
    <item>
      <title>Just say No to loops and variables.</title>
      <link>https://joshwulf.com/blog/2020/02/just-say-no-to-loops-and-variables/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/02/just-say-no-to-loops-and-variables/</guid>
      <description>Recently, I spent some time on StackOverflow, helping people with their school assignments - I mean, serious programming questions they had at work. (I&#39;m pretty sure a fair whack of them were homework assignments).
One thing that came out of it - for me - was a pattern in the issues in the JavaScript programming tag (Discord bots are hot right now with the kids).
There are certain things that people struggle with when learning to program, and when learning to program in JS.</description>
    </item>
    
    <item>
      <title>How to write a GitHub Action</title>
      <link>https://joshwulf.com/blog/2020/02/creating-github-action/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/02/creating-github-action/</guid>
      <description>GitHub Actions are small, reusable modules of functionality that can participate in GitHub Workflows. You can add a GitHub workflow yaml file to any GitHub repo, and have it run in response to events like code pushes, pull requests - even arbitrary events posted to the repository&#39;s repository_dispatch REST endpoint over the GitHub API.
The obvious things they can be used for are running tests, linting code or rebuilding artifacts on check-in, creating releases, even deploying from a particular branch.</description>
    </item>
    
    <item>
      <title>20 Tips on travelling like a BOSS</title>
      <link>https://joshwulf.com/blog/2020/01/travel-tips/</link>
      <pubDate>Thu, 30 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/01/travel-tips/</guid>
      <description>Over the last 20 years, I&#39;ve done a fair amount of travel around the world. My first trip out of New Zealand on my own - in 1996, to Sydney - was a hot mess. I had no idea that you have to pass through a metal detector at the airport, and I rocked up with batteries, coins, a metal chain on my wallet, a Maglite torch, and a multi-headed screwdriver in my pockets.</description>
    </item>
    
    <item>
      <title>Implementing a Maybe Pattern using a TypeScript Type Guard</title>
      <link>https://joshwulf.com/blog/2019/02/typescript-maybe/</link>
      <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2019/02/typescript-maybe/</guid>
      <description>You’re sat at a restaurant, and you order a beer. The waiter disappears into the kitchen, and returns a couple of minutes later, empty-handed. “I’m sorry,” he says. “I could not get your beer.”
Now here is the six-million dollar question: is the restaurant out of the beer that you ordered (business logic), or is the restaurant kitchen on fire (infrastructure failure)?
And how do you model those two distinct failure states in your API?</description>
    </item>
    
    <item>
      <title>Node.js client for Zeebe Microservices Orchestration Engine</title>
      <link>https://joshwulf.com/blog/2019/01/zeebe-node/</link>
      <pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2019/01/zeebe-node/</guid>
      <description>Update: I now work at Camunda on Zeebe as the Node client maintainer and a Developer Advocate. Things have changed in the broker and the library since this was published - for the latest on using it, refer to my new book in development - &amp;ldquo;The Zeebe Node.js Client Guide&amp;quot;
I’m proud to announce that Credit Sense has open-sourced our Node.js client library for Zeebe. Check it out on GitHub and start using it now!</description>
    </item>
    
    <item>
      <title>Programming Quantum Computers with Q#</title>
      <link>https://joshwulf.com/blog/2018/09/programming-in-q#/</link>
      <pubDate>Thu, 20 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2018/09/programming-in-q#/</guid>
      <description>This week I’m at the NDC Developer Conference in Sydney. While here, I attended a workshop on programming Quantum computers using Q#, run by John Azariah, the creator of the Q# programming language.
We&amp;#39;re on Task 1.2 of the Q# quantum programming workshop. Linear vector algebra in multi-dimensional complex space... Entanglement and teleportation are coming. pic.twitter.com/wU7LVSeozv
&amp;mdash; Josh Wulf (Alt Super Meta) (@sitapati) September 19, 2018  Q# is a recently released Microsoft language specifically developed for programming quantum computer operations from a classical computer.</description>
    </item>
    
    <item>
      <title>JavaScript: Return considered harmful</title>
      <link>https://joshwulf.com/blog/2017/11/return-considered-harmful/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2017/11/return-considered-harmful/</guid>
      <description>JavaScript — the language of the Gods.
return — basically the GOTO statement of 2017_*_
_* T&amp;amp;C apply._
Born in the turbulent crucible of an asynchronous environment, with unpredictable response times and failure rates. For programmers coming from a traditional multi-threaded environment like Java or C#, JavaScript lives in strange and alien world where storms the size of entire planets rage, and lightning bolts pierce the ether.
The classic newbie mistake in JavaScript is to ask: “Why doesn’t this work?</description>
    </item>
    
    <item>
      <title>Righto — async done right in JavaScript</title>
      <link>https://joshwulf.com/blog/2017/06/righto/</link>
      <pubDate>Sat, 10 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2017/06/righto/</guid>
      <description>If you program in server-side JavaScript there is no way that you can avoid dealing with asynchronous functions.
Callbacks, Promises, and async/await are some of the ways that you may have heard of dealing with asynchronous programming in JavaScript. But you may not have heard of Righto — literally the best library of all time for async programming in JS.
Kory Nunn’s Righto library is — according to him — way better than Promises and Async/Await combined.</description>
    </item>
    
    <item>
      <title>There is no good coding, only good refactoring</title>
      <link>https://joshwulf.com/blog/2017/04/no-good-coding/</link>
      <pubDate>Sat, 15 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2017/04/no-good-coding/</guid>
      <description>On a standard 101-key keyboard, there are 100 keys that increase technical debt, and only one key that reduces it.
 When you write code you produce functionality and technical debt. Refactoring code is the process of reducing technical debt while preserving functionality.
Yesterday, I spent the afternoon refactoring a method in one of the Magikcraft components.
I refactored it three or four times, extracting and consolidating pieces of logic.</description>
    </item>
    
  </channel>
</rss>