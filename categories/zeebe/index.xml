<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>zeebe on Josh Wulf</title>
    <link>https://joshwulf.com/categories/zeebe/</link>
    <description>Recent content in zeebe on Josh Wulf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 23 Jun 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://joshwulf.com/categories/zeebe/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Writing a Zeebe Client in 2020</title>
      <link>https://joshwulf.com/blog/2020/06/zeebe-2020/</link>
      <pubDate>Tue, 23 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/06/zeebe-2020/</guid>
      <description>The last time we wrote about creating a Zeebe Client was in November, 2018 in the article &amp;ldquo;Generating a Zeebe-Python Client Stub in Less Than An Hour: A gRPC + Zeebe Tutorial&amp;rdquo;.
As of June 18, 2020, we have Zeebe client libraries in Java and Go, maintained by the core Zeebe Engineering team, as well as community-supported clients in C#, Delphi, Node.js, Python, Ruby, and Rust; as well as Workit - a Node.</description>
    </item>
    
    <item>
      <title>The Zeebe Node Batch Worker</title>
      <link>https://joshwulf.com/blog/2020/03/zb-batch-worker/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/03/zb-batch-worker/</guid>
      <description>Zeebe is a workflow engine for orchestrating microservices, using BPMN models to define complex workflows that can be monitored operationally using a graphical representation of the process state.
Thanks to a feature request from Jimmy Beaudoin, the 0.23.0-alpha.1 release of the Zeebe Node client introduces a new worker - the ZBBatchWorker.
Motivation Sometimes you have external resources that your microservices access - maybe a database or a rate-limited or pay-per-call API.</description>
    </item>
    
    <item>
      <title>Refactoring the Zeebe Node gRPC State Machine for Camunda Cloud: Part Two</title>
      <link>https://joshwulf.com/blog/2020/03/camunda-cloud-connection-2/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/03/camunda-cloud-connection-2/</guid>
      <description>See Part One of this series here.
I&amp;rsquo;m refactoring the Zeebe Node client to give it the ergonomic excellence that developers have come to expect from the library, when running it against Zeebe clusters in Camunda Cloud.
Right now, here is what it looks like connecting to Camunda Cloud with the Zeebe Node client:
   Boo!
The gRPC connection with Camunda Cloud has different characteristics to self-hosted Zeebe, particularly on initial connection, and there is nowhere in the current Node client architecture to model different expectations of connection behaviour.</description>
    </item>
    
    <item>
      <title>Providing a method signature overload for Zeebe Node&#39;s `createWorker` using TypeScript</title>
      <link>https://joshwulf.com/blog/2020/02/refining-method-signature/</link>
      <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/02/refining-method-signature/</guid>
      <description>When I wrote the first iteration of the Zeebe Node client library in the first months of 2019, I didn&amp;rsquo;t have any experience in using it. How could I - it didn&amp;rsquo;t exist.
One early design decision has haunted me for the last year, causing me sleepless nights as I toss and turn, tormented by my guilty conscience.
The ZBClient.createWorker() method - to create a new job worker process - takes as one of its parameters an id, used to uniquely identify a specific instance of a worker in events exported from the broker.</description>
    </item>
    
    <item>
      <title>Refactoring the Zeebe Node gRPC State Machine for Camunda Cloud: Part One</title>
      <link>https://joshwulf.com/blog/2020/02/camunda-cloud-connection/</link>
      <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/02/camunda-cloud-connection/</guid>
      <description>Preparing for the launch of Camunda Cloud, I turned on continuous integration testing for the Zeebe Node.js client against a running instance of a Camunda Cloud Zeebe cluster.
I was immediately forced to deal with something I&amp;rsquo;d been conveniently ignoring:
Camunda Cloud gRPC connections always report failure initially, before eventually succeeding.
This is because the connection to Camunda Cloud is via a TLS-enabled Nginx reverse proxy with OAuth authentication. This causes the current gRPC client state machine to emit intermediate connection failure events before emitting an eventual &amp;ldquo;READY&amp;rdquo; state.</description>
    </item>
    
    <item>
      <title>A Functional Refactor of Zeebe Node with fp-ts</title>
      <link>https://joshwulf.com/blog/2020/02/functional-refactor/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/02/functional-refactor/</guid>
      <description>There is no such thing as good coding, only good refactoring.
 I recently did a bunch of work on the Zeebe Node.js client for the upcoming 0.23 release. Zeebe Node is a client library for the Zeebe Microservices Workflow Orchestration Engine, and I maintain it.
While doing other work, I took the opportunity to refactor one method, deployWorkflows, to add a feature that I wanted it to have. I used fp-ts, a TypeScript Functional Programming library to do it.</description>
    </item>
    
    <item>
      <title>20 Tips on travelling like a BOSS</title>
      <link>https://joshwulf.com/blog/2020/01/travel-tips/</link>
      <pubDate>Thu, 30 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2020/01/travel-tips/</guid>
      <description>Over the last 20 years, I&amp;rsquo;ve done a fair amount of travel around the world. My first trip out of New Zealand on my own - in 1996, to Sydney - was a hot mess. I had no idea that you have to pass through a metal detector at the airport, and I rocked up with batteries, coins, a metal chain on my wallet, a Maglite torch, and a multi-headed screwdriver in my pockets.</description>
    </item>
    
    <item>
      <title>Zero-Scale Zeebe with Cloudflare Workers</title>
      <link>https://joshwulf.com/blog/2019/12/cloudflare-slack/</link>
      <pubDate>Tue, 03 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2019/12/cloudflare-slack/</guid>
      <description>I get questions about running Zeebe at &amp;ldquo;zero-scale&amp;rdquo;. That means workers that consume no resources when there are no tasks to perform.
The Zeebe service on Camunda Cloud includes a generic HTTP-Worker that can be used to achieve this. The HTTP-Worker polls for jobs of type &amp;ldquo;Camunda-HTTP&amp;rdquo;, and then invokes a REST endpoint based on the HTTP verb and URL set in the task headers. If you are not on Camunda Cloud you can use zeebe-http-worker, or just write your own.</description>
    </item>
    
    <item>
      <title>Node.js client for Zeebe Microservices Orchestration Engine</title>
      <link>https://joshwulf.com/blog/2019/01/zeebe-node/</link>
      <pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://joshwulf.com/blog/2019/01/zeebe-node/</guid>
      <description>Update: I now work at Camunda on Zeebe as the Node client maintainer and a Developer Advocate. Things have changed in the broker and the library since this was published - for the latest on using it, refer to my new book in development - &amp;ldquo;The Zeebe Node.js Client Guide&amp;quot;
Iâ€™m proud to announce that Credit Sense has open-sourced our Node.js client library for Zeebe. Check it out on GitHub and start using it now!</description>
    </item>
    
  </channel>
</rss>
